#!/bin/sh

#
#----WCOSS_CRAY JOBCARD
#
#BSUB -L /bin/sh
#BSUB -P FV3GFS-T2O
#BSUB -oo log.grid.%J
#BSUB -eo log.grid.%J
#BSUB -J grid_fv3
#BSUB -q debug
#BSUB -M 2400
#BSUB -W 00:30
#BSUB -extsched 'CRAYLINUX[]'
#
#----THEIA JOBCARD
#
#PBS -N make_grid_orog_rgnl
#PBS -A gsd-fv3
#PBS -o out.$PBS_JOBNAME.$PBS_JOBID
#PBS -e err.$PBS_JOBNAME.$PBS_JOBID
#PBS -l nodes=1:ppn=24
#PBS -q debug
#PBS -l walltime=00:30:00
#PBS -W umask=022
#



#
#-----------------------------------------------------------------------
#
# This script generates grid and orography files in NetCDF format that 
# are required as inputs for running the FV3SAR model (i.e. the FV3 mo-
# del on a regional domain).  It in turn calls three other scripts whose
# file names are specified in the variables grid_gen_scr, orog_gen_scr,
# and orog_fltr_scr and then calls the executable defined in the vari-
# able shave_exec.  These scripts/executable perform the following 
# tasks:
#
# 1) grid_gen_scr:
#
#    This script enerates grid files that will be used by subsequent 
#    preprocessing steps.  It places its output in the temporary direc-
#    tory defined in WORKDIR_GRID (which is somewhere under TMPDIR).  
#    Note that:
#
#    a) This script creates grid files for each of the 7 tiles of the 
#       cubed sphere grid (where tiles 1 through 6 cover the globe, and
#       tile 7 is the regional grid located somewhere within tile 6) 
#       even though the forecast will be performed only on tile 7.
#
#    b) The tile 7 grid that this script creates includes a halo (i.e. 
#       a layer of cells beyond the boundary of tile 7).  The width of
#       this halo (i.e. the number of cells in the halo in the direction
#       perpendicular to the boundary of the tile) is determined by the
#       variable nhalo_T7 set below.  This variable will be set such
#       that the "shave" steps later below (which shave off layers of 
#       cells from the halo in this file to create grid files with thin-
#       ner halos that are needed as inputs to the FV3SAR model) can 
#       shave off halo cells without removing cells from within the 
#       boundary of tile 7.  (More specifically, the FV3SAR model needs
#       as inputs two grid files: one with 3 halo cells and another with
#       4.  Thus, nhalo_T7 must be greater than 4.)  
#
# 2) orog_gen_scr:
#
#    This script generates the orography file.  It places its output in
#    the temporary directory defined in WORKDIR_OROG (which is somewhere
#    under TMPDIR).  Note that:
#
#    a) This script generates an orography file only on tile 7.
#
#    b) This orography file contains a halo of the same width (nhalo_T7)
#       as the grid file for tile 7 generated by the grid_gen_scr script
#       in the previous step.  
#
# 3) orog_fltr_scr:
#
#    This script generates a filtered version of the orography file ge-
#    nerated by the script orog_gen_scr.  This script places its output
#    in the temporary directory defined in WORKDIR_FLTR (which is some-
#    where under TMPDIR).  Note that:
#
#    a) The filtered orography file generated by this script contains a
#       halo of the same width (nhalo_T7) as the (unfiltered) orography
#       file generated by script orog_gen_scr (and the grid file genera-
#       ted by grid_gen_scr).
#
#    b) In analogy with the input grid files, the FV3SAR model needs as 
#       input two (filtered) orography files -- one with no halo cells 
#       and another with 3.  These are obtained later below by "shaving" 
#       off layers of halo cells from the (filtered) orography file ge-
#       nerated in this step.
#
# 4) shave_exec:
#
#    This "shave" executable is called 4 times to generate 4 files from
#    the tile 7 grid file generated by grid_gen_scr and the tile 7 fil-
#    tered orography file generated by orog_fltr_scr (both of which have
#    a halo of width nhalo_T7 cells).  The 4 output files are placed in
#    the temporary directory defined in WORKDIR_SHVE (which is somewhere
#    under TMPDIR).  More specifically:
#
#    a) shave_exec is called to shave the halo in the tile 7 grid file 
#       generated by grid_gen_scr down to a width of 3 cells and store
#       the result in a new grid file in WORKDIR_SHVE.
#
#    b) shave_exec is called to shave the halo in the tile 7 grid file 
#       generated by grid_gen_scr down to a width of 4 cells and store 
#       the result in a new grid file in WORKDIR_SHVE.
#
#    c) shave_exec is called to shave the halo in the tile 7 filtered
#       orography file generated by orog_fltr_scr down to a width of 0
#       cells (i.e. no halo) and store the result in a new filtered oro-
#       graphy file in WORKDIR_SHVE.
#
#    d) shave_exec is called to shave the halo in the tile 7 filtered
#       orography file generated by orog_fltr_scr down to a width of 4
#       cells and store the result in a new filtered orography file in
#       WORKDIR_SHVE.
#
#-----------------------------------------------------------------------
#

#
#-----------------------------------------------------------------------
#
# Change shell behavior with "set" with these flags:
#
# -a 
# This will cause the script to automatically export all variables and 
# functions which are modified or created to the environments of subse-
# quent commands.
#
# -e 
# This will cause the script to exit as soon as any line in the script 
# fails (with some exceptions; see manual).  Apparently, it is a bad 
# idea to use "set -e".  See here:
#   http://mywiki.wooledge.org/BashFAQ/105
#
# -u 
# This will cause the script to exit if an undefined variable is encoun-
# tered.
#
# -x
# This will cause all executed commands in the script to be printed to 
# the terminal (used for debugging).
#
#-----------------------------------------------------------------------
#
set -eux
#set -ux

#
#-----------------------------------------------------------------------
#
# Source the script that defines the necessary shell environment varia-
# bles.
#
#-----------------------------------------------------------------------
#
. $RUNDIR/var_defns.sh
export gtype
#
#-----------------------------------------------------------------------
#
# Set the file names of the scripts to use for generating the grid 
# files, the orography files, and for filtering the orography files, 
# respectively.  Also, set the name of the executable file used to 
# "shave" (i.e. remove the halo from) certain grid and orography 
# files.  The shaving is needed only for the gtype="regional" case.
#
#-----------------------------------------------------------------------
#
grid_gen_scr="fv3gfs_make_grid.sh"
orog_gen_scr="fv3gfs_make_orog.sh"
orog_fltr_scr="fv3gfs_filter_topo.sh"
shave_exec="shave.x"
#
#-----------------------------------------------------------------------
#
# Set stack size to unlimited.
#
#-----------------------------------------------------------------------
#
ulimit -a
ulimit -s unlimited
#
#-----------------------------------------------------------------------
#
# The orography code runs with threads.  On Cray, the code is optimized 
# for six threads.  Do not change.  
# Note that OMP_NUM_THREADS and OMP_STACKSIZE only affect the threaded   <== I don't think this is true.  Remove??
# executions on Cray; they don't affect executions on theia.
#
#-----------------------------------------------------------------------
#
export OMP_NUM_THREADS=6
export OMP_STACKSIZE=2048m
#
#-----------------------------------------------------------------------
#
# Load modules and set various computational parameters and directories.
#
# topo_dir specifies the directory in which input files needed for gene-
# rating the orography (topography) files are located.
#
#-----------------------------------------------------------------------
#
if [ "$machine" = "WCOSS_C" ]; then

  set +x
  . $MODULESHOME/init/sh
  module load PrgEnv-intel cfp-intel-sandybridge/1.1.0
  module list
  set -x

  export NODES=1
  export APRUN="aprun -n 1 -N 1 -j 1 -d 1 -cc depth"
  export KMP_AFFINITY=disabled
  export topo_dir=/gpfs/hps/emc/global/noscrub/emc.glopara/svn/fv3gfs/fix/fix_orog

elif [ "$machine" = "THEIA" ]; then

  . /apps/lmod/lmod/init/sh

  set +x
  module purge
  module load intel/16.1.150
  module load impi
  module load hdf5/1.8.14
  module load netcdf/4.3.0
  module list
  set -x

  export APRUN="time"
  export topo_dir="/scratch4/NCEPDEV/global/save/glopara/svn/fv3gfs/fix/fix_orog"

else

  echo
  echo "Error.  Machine specified in \"machine\" is not supported:"
  echo "  machine = $machine"
  echo "Exiting script."
  exit 1

fi
#
#-----------------------------------------------------------------------
#
# Set the directory in which all executables called by this script are
# located.
#
#-----------------------------------------------------------------------
#
export exec_dir="$BASE_GSM/exec"
#
#-----------------------------------------------------------------------
#
# Create the various directories needed by the various steps/substeps in
# this script.
#
#-----------------------------------------------------------------------
#
mkdir $WORKDIR_GRID
mkdir $WORKDIR_OROG
mkdir $WORKDIR_FLTR
mkdir $WORKDIR_SHVE
mkdir $WORKDIR_ICBC
#
#-----------------------------------------------------------------------
#
# We want to construct a regional grid with a specified number of halo 
# cells along the four edges of the grid (i.e. left, right, bottom, and
# top edges).  These halo cells extend beyond the boundary of the re-
# gional domain and are used to feed in external boundary conditions to
# the FV3SAR model.
#
# The grid generation script grid_gen_scr calls the make_hgrid executa-
# ble to construct the regional grid.  This executable in turn accepts 
# as arguments the index limits (i.e. starting and ending indices) of
# the regional grid on the supergrid of the regional grid's parent tile
# (where the parent tile is tile 6, and the supergrid of any given tile
# is the grid obtained by doubling the number of cells in each direction
# on that tile's grid).  We will denote these index limits by
#
#   istart_rgnl_T6SG
#   iend_rgnl_T6SG
#   jstart_rgnl_T6SG
#   jend_rgnl_T6SG
#
# Recall, however, that we have as inputs the index limits of the re-
# gional grid on the tile 6 grid (not its supergrid).  These are given
# by
#
#   istart_rgnl_T6
#   iend_rgnl_T6
#   jstart_rgnl_T6
#   jend_rgnl_T6
#
# We can obtain the former from the latter by recalling that the super-
# grid has twice the resolution of the original grid.  Thus,
#
#   istart_rgnl_T6SG = 2*istart_rgnl_T6 - 1
#   iend_rgnl_T6SG = 2*iend_rgnl_T6
#   jstart_rgnl_T6SG = 2*jstart_rgnl_T6 - 1
#   jend_rgnl_T6SG = 2*jend_rgnl_T6
#
# We perfrom these calculations next.
#
#-----------------------------------------------------------------------
#
istart_rgnl_T6SG=$(( 2*$istart_rgnl_T6 - 1 ))
iend_rgnl_T6SG=$(( 2*$iend_rgnl_T6 ))
jstart_rgnl_T6SG=$(( 2*$jstart_rgnl_T6 - 1 ))
jend_rgnl_T6SG=$(( 2*$jend_rgnl_T6 ))
#
#-----------------------------------------------------------------------
#
# If we simply pass to make_hgrid the index limits of the regional grid
# on the tile 6 supergrid calculated above, make_hgrid will generate a
# regional grid without a halo.  To obtain a regional grid with a halo,
# we must pass to make_hgrid the index limits (on the tile 6 supergrid)
# of the regional grid including a halo.  We will let the variables 
#
#   istart_rgnl_with_halo_T6SG
#   iend_rgnl_with_halo_T6SG
#   jstart_rgnl_with_halo_T6SG
#   jend_rgnl_with_halo_T6SG
#
# denote these limits.  Next, we describe how to calculate these values.
#
# Let nhalo_T7 denote the width of the halo in units of number of grid
# cells on the regional grid (i.e. tile 7) that we'd like to have along
# all four edges of the regional domain (left, right, bottom, and top).  
# To obtain the corresponding halo width in units of number of cells on
# the tile 6 grid -- which we denote by nhalo_T6 -- we simply divide 
# nhalo_T7 by the refinement ratio, i.e.
#
#   nhalo_T6 = nhalo_T7/refine_ratio
#
# The corresponding halo width on the tile 6 supergrid is then given by
#
#   nhalo_T6SG = 2*nhalo_T6
#              = 2*nhalo_T7/refine_ratio
#
# Note that nhalo_T6SG must be an integer, but the expression derived 
# above for it may not yield an integer.  To ensure that the halo has
# a width of at least nhalo_T7 cells on the regional grid, we round up
# the result of the expression above for nhalo_T6SG, i.e. we redefine
# nhalo_T6SG to be
#
#   nhalo_T6SG = ceil(2*nhalo_T7/refine_ratio)
#
# where ceil(...) is the ceiling function, i.e. it rounds its floating
# point argument up to the next larger integer.  Since in bash division
# of two integers returns a truncated integer and since bash has no 
# ceil(...) function, we instead perform the rounding-up operation by 
# adding the denominator (of the argument of ceil(...) above) minus one
# to the original numerator, i.e. by redefining nhalo_T6SG to be
#
#   nhalo_T6SG = (2*nhalo_T7 + refine_ratio - 1)/refine_ratio
#
# (This trick works when dividing one positive integer by another.)  
# Once we obtain nhalo_T6SG using this expression, we can obtain the 
# tile 6 supergrid index limits for the regional domain with halo from
# the index limits for the regional domain without a halo by simply sub-
# tracting nhalo_T6SG from the lower index limits and adding nhalo_T6SG
# to the upper index limits, i.e.
#
#   istart_rgnl_with_halo_T6SG = istart_rgnl_T6SG - nhalo_T6SG
#   iend_rgnl_with_halo_T6SG = iend_rgnl_T6SG + nhalo_T6SG
#   jstart_rgnl_with_halo_T6SG = jstart_rgnl_T6SG - nhalo_T6SG
#   jend_rgnl_with_halo_T6SG = jend_rgnl_T6SG + nhalo_T6SG
#
#-----------------------------------------------------------------------
#
nhalo_T7=$(( $halop1 + 1 ))
nhalo_T6SG=$(( (2*nhalo_T7 + refine_ratio - 1)/refine_ratio ))

istart_rgnl_with_halo_T6SG=$(( $istart_rgnl_T6SG - $nhalo_T6SG ))
iend_rgnl_with_halo_T6SG=$(( $iend_rgnl_T6SG + $nhalo_T6SG ))
jstart_rgnl_with_halo_T6SG=$(( $jstart_rgnl_T6SG - $nhalo_T6SG ))
jend_rgnl_with_halo_T6SG=$(( $jend_rgnl_T6SG + $nhalo_T6SG ))
#
#-----------------------------------------------------------------------
#
# A restriction (that probably originates from make_hgrid) on the start-
# ing and ending indices of the regional or nested domains is that 
# istart_rgnl_with_halo_T6SG and jstart_rgnl_with_halo_T6SG (as well as istart_rgnl_T6SG and 
# jstart_rgnl_T6SG) must be odd, and iend_rgnl_with_halo_T6SG and jend_rgnl_with_halo_T6SG (as 
# well as iend_rgnl_T6SG and jend_rgnl_T6SG) must be even.  These restrictions 
# imply that the boundary of the regional or nested grid (with or with-
# out a halo) must coincide with the gridlines of the parent grid; it
# must not coincide with the half-gridlines (i.e. the lines on which the 
# mass points lie) of the parent grid.  Thus, below, after calculating
# the starting and ending indices using the formulas above, we ensure
# that the starting indices are odd and the ending indices are even by
# appropriately adjusting them by 1.
#
#-----------------------------------------------------------------------
#
if [ $(( istart_rgnl_with_halo_T6SG%2 )) -eq 0 ]; then
  istart_rgnl_with_halo_T6SG=$(( istart_rgnl_with_halo_T6SG - 1 ))
fi
if [ $(( iend_rgnl_with_halo_T6SG%2 )) -eq 1 ]; then
  iend_rgnl_with_halo_T6SG=$(( iend_rgnl_with_halo_T6SG + 1 ))
fi

if [ $(( jstart_rgnl_with_halo_T6SG%2 )) -eq 0 ]; then
  jstart_rgnl_with_halo_T6SG=$(( jstart_rgnl_with_halo_T6SG - 1 ))
fi
if [ $(( jend_rgnl_with_halo_T6SG%2 )) -eq 1 ]; then
  jend_rgnl_with_halo_T6SG=$(( jend_rgnl_with_halo_T6SG + 1 ))
fi
#
#-----------------------------------------------------------------------
#
# Now that the starting and ending tile 6 supergrid indices of the re-
# gional grid with a halo have been calculated, recalculate the halo
# width (on the tile 6 supergrid, on tile 6, and on tile 7).
#
#-----------------------------------------------------------------------
#
set -x

echo
echo "Original values of halo width on tile 6 supergrid and on tile 7:"
echo "  nhalo_T6SG = $nhalo_T6SG"
echo "  nhalo_T7 = $nhalo_T7"

nhalo_T6SG=$(( $istart_rgnl_T6SG - $istart_rgnl_with_halo_T6SG ))
nhalo_T6=$(( $nhalo_T6SG/2 ))
nhalo_T7=$(( $nhalo_T6*$refine_ratio ))

echo "Values of halo width on tile 6 supergrid and on tile 7 AFTER adjustments:"
echo "  nhalo_T6SG = $nhalo_T6SG"
echo "  nhalo_T7 = $nhalo_T7"

set +x
#
#-----------------------------------------------------------------------
#
# Calculate the number of cells that the regional domain has in each of
# the two horizontal directions (say x and y).  We denote these by nx_T7
# and ny_T7, respectively.  These will be needed in the "shave" steps 
# later below.
#
#-----------------------------------------------------------------------
#
set +x

nx_T6SG=$(( $iend_rgnl_T6SG - $istart_rgnl_T6SG + 1 ))
nx_T6=$(( $nx_T6SG/2 ))
nx_T7=$(( $nx_T6*$refine_ratio ))

ny_T6SG=$(( $jend_rgnl_T6SG - $jstart_rgnl_T6SG + 1 ))
ny_T6=$(( $ny_T6SG/2 ))
ny_T7=$(( $ny_T6*$refine_ratio ))

echo
echo "ny_T7 = $ny_T7 (jstart_rgnl_T6SG = $jstart_rgnl_T6SG, jend_rgnl_T6SG = $jend_rgnl_T6SG)"
echo "nx_T7 = $nx_T7 (istart_rgnl_T6SG = $istart_rgnl_T6SG, iend_rgnl_T6SG = $iend_rgnl_T6SG)"

set +x
#
#-----------------------------------------------------------------------
#
# For informational purposes, calculate the number of cells in the re-
# gional domain WITH a halo of width nhalo_T7 cells.  We denote these by
# nx_with_halo_T7 and ny_with_halo_T7, respectively.
#
#-----------------------------------------------------------------------
#
set -x

nx_with_halo_T6SG=$(( $iend_rgnl_with_halo_T6SG - $istart_rgnl_with_halo_T6SG + 1 ))
nx_with_halo_T6=$(( $nx_with_halo_T6SG/2 ))
nx_with_halo_T7=$(( $nx_with_halo_T6*$refine_ratio ))

ny_with_halo_T6SG=$(( $jend_rgnl_with_halo_T6SG - $jstart_rgnl_with_halo_T6SG + 1 ))
ny_with_halo_T6=$(( $ny_with_halo_T6SG/2 ))
ny_with_halo_T7=$(( $ny_with_halo_T6*$refine_ratio ))

echo
echo "ny_with_halo_T7 = $ny_T7 (jstart_rgnl_with_halo_T6SG = $jstart_rgnl_with_halo_T6SG, jend_rgnl_with_halo_T6SG = $jend_rgnl_with_halo_T6SG)"
echo "nx_with_halo_T7 = $nx_T7 (istart_rgnl_with_halo_T6SG = $istart_rgnl_with_halo_T6SG, iend_rgnl_with_halo_T6SG = $iend_rgnl_with_halo_T6SG)"

set -x
#
#-----------------------------------------------------------------------
#  
# Generate grid files. 
#
# The following will create 7 grid files (one per tile, where the 7th 
# "tile" is the grid that covers the regional domain) named 
#
#   ${CRES}_grid.tileN.nc for N=1,...,7.  
#
# It will also create a mosaic file named ${CRES}_mosaic.nc that con-
# tains information only about tile 7 (i.e. it does not have any infor-
# mation on how tiles 1 through 6 are connected or that tile 7 is within
# tile 6).  All these files will be placed in the directory specified by
# WORKDIR_GRID.  Note that the file for tile 7 will include a halo of 
# width nhalo_T7 cells.
#
# Since tiles 1 through 6 are not needed to run the FV3SAR model and are
# not used later on in any other preprocessing steps, it is not clear 
# why they are generated.  It might be because it is not possible to di-
# rectly generate a standalone regional grid using the make_hgrid uti-
# lity/executable that grid_gen_scr calls, i.e. it might be because with
# make_hgrid, one has to either create just the 6 global tiles or create
# the 6 global tiles plus the regional (tile 7), and then for the case
# of a regional simulation (i.e. gtype="regional", which is always the
# case here) just not use the 6 global tiles.
#  
# The grid_gen_scr script called below takes its next-to-last argument 
# and passes it as an argument to the --halo flag of the make_hgrid uti-
# lity/executable.  make_hgrid then checks that a regional (or nested) 
# grid of size specified by the arguments to its --istart_nest, --iend_-
# nest, --jstart_nest, and --jend_nest flags with a halo around it of 
# size specified by the argument to the --halo flag does not extend be-
# yond the boundaries of the parent grid (tile 6).  In this case, since
# the values passed to the --istart_nest, ..., and --jend_nest flags al-
# ready include a halo (because these arguments are $istart_rgnl_with_-
# halo_T6SG, $iend_rgnl_with_halo_T6SG, $jstart_rgnl_with_halo_T6SG, and
# $jend_rgnl_with_halo_T6SG), it is reasonable to pass as the argument
# to --halo a zero.  However, make_hgrid requires that the argument to
# --halo be at least 1, so below, we pass a 1 as the next-to-last argu-
# ment to grid_gen_scr.
#
# More information on make_hgrid:
# ------------------------------
#
# The grid_gen_scr called below in turn calls the make_hgrid executable
# as follows:
#
#   make_hgrid \
#   --grid_type gnomonic_ed \
#   --nlon 2*${RES} \
#   --grid_name C${RES}_grid \
#   --do_schmidt --stretch_factor ${stretch_fac} \
#   --target_lon ${target_lon} --target_lat ${target_lat} \
#   --nest_grid --parent_tile 6 --refine_ratio ${refine_ratio} \
#   --istart_nest ${istart_rgnl_with_halo_T6SG} \
#   --jstart_nest ${jstart_rgnl_with_halo_T6SG} \
#   --iend_nest ${iend_rgnl_with_halo_T6SG} \
#   --jend_nest ${jend_rgnl_with_halo_T6SG} \
#   --halo ${halo} \
#   --great_circle_algorithm
#
# This creates the 7 grid files ${CRES}_grid.tileN.nc for N=1,...,7.  
# The 7th file ${CRES}_grid.tile7.nc represents the regional grid, and 
# the extents of the arrays in that file do not seem to include a halo,
# i.e. they are based only on the values passed via the four flags
#
#   --istart_nest ${istart_rgnl_with_halo_T6SG}
#   --jstart_nest ${jstart_rgnl_with_halo_T6SG}
#   --iend_nest ${iend_rgnl_with_halo_T6SG}
#   --jend_nest ${jend_rgnl_with_halo_T6SG}
#
# According to Rusty Benson of GFDL, the flag
#
#   --halo ${halo}
#
# only checks to make sure that the nested or regional grid combined
# with the specified halo lies completely within the parent tile.  If
# so, make_hgrid issues a warning and exits.  Thus, the --halo flag is
# not meant to be used to add a halo region to the nested or regional
# grid whose limits are specified by the flags --istart_nest, --iend_-
# nest, --jstart_nest, and --jend_nest.
# 
# Note also that make_hgrid has an --out_halo option that, according to
# the documentation, is meant to output extra halo cells around the
# nested or regional grid boundary in the file generated by make_hgrid.
# However, according to Rusty Benson of GFDL, this flag was originally 
# created for a special purpose and is limited to only outputting at 
# most 1 extra halo point.  Thus, it should not be used.
#  
#-----------------------------------------------------------------------
#
echo 
echo "Begin grid file generation (on `date`)."

$USHDIR/$grid_gen_scr \
  $RES \
  $WORKDIR_GRID \
  $stretch_fac $target_lon $target_lat $refine_ratio \
  $istart_rgnl_with_halo_T6SG $jstart_rgnl_with_halo_T6SG \
  $iend_rgnl_with_halo_T6SG $jend_rgnl_with_halo_T6SG \
  1 \
  $USHDIR
#
#-----------------------------------------------------------------------
#
# For clarity, rename the tile 7 grid file such that its new name con-
# tains the halo size.  Then create a link whose name doesn't contain
# the halo size that points to this file.
#
#-----------------------------------------------------------------------
#
tile=7
cd $WORKDIR_GRID
mv ${CRES}_grid.tile${tile}.nc \
   ${CRES}_grid.tile${tile}.halo${nhalo_T7}.nc
ln -fs ${CRES}_grid.tile${tile}.halo${nhalo_T7}.nc \
       ${CRES}_grid.tile${tile}.nc
cd -

echo 
echo "End grid file generation (on `date`)."
#
#-----------------------------------------------------------------------
#  
# Generate an orography file corresponding to tile 7 (the regional do-
# main) only.  
#
# The following will create an orography file named 
# 
#   oro.${CRES}.tile7.nc 
#
# and will place it in WORKDIR_OROG.  Note that this file will include
# orography for a halo of width nhalo_T7 cells around tile 7.  The fol-
# lowing will also create a work directory called tile7 under WORKDIR_-
# OROG.  This work directory can be removed after the orography file has
# been created (it is currently not deleted).
#  
#-----------------------------------------------------------------------
#  
tile=7
echo
echo "Begin orography file generation (on `date`)."

if [ "$machine" = "WCOSS_C" ]; then
#
# On WCOSS and WCOSS_C, use cfp to run multiple tiles simulatneously for 
# the orography.  For now, we have only one tile in the regional case, 
# but in the future we will have more.  First, create an input file for 
# cfp.
#
  export APRUN=time
  echo "$USHDIR/$orog_gen_scr $RES $tile $WORKDIR_GRID $WORKDIR_OROG $USHDIR $topo_dir $TMPDIR " >> $TMPDIR/orog.file1

  aprun -j 1 -n 4 -N 4 -d 6 -cc depth cfp $TMPDIR/orog.file1
  rm $TMPDIR/orog.file1

elif [ "$machine" = "THEIA" ]; then

  echo
  echo "Executing $orog_gen_scr for tile $tile..."
  $USHDIR/$orog_gen_scr $RES $tile $WORKDIR_GRID $WORKDIR_OROG $USHDIR $topo_dir $TMPDIR
  echo
  echo "Done executing $orog_gen_scr for tile $tile."

fi
#  
#-----------------------------------------------------------------------
#
# For clarity, rename the tile 7 orography file such that its new name
# contains the halo size.  Then create a link whose name doesn't contain
# the halo size that points to this file.
#
#-----------------------------------------------------------------------
#
tile=7
cd $WORKDIR_OROG 
mv oro.${CRES}.tile${tile}.nc \
   oro.${CRES}.tile${tile}.halo${nhalo_T7}.nc
ln -fs oro.${CRES}.tile${tile}.halo${nhalo_T7}.nc \
       oro.${CRES}.tile${tile}.nc
cd -

echo
echo "End orography file generation (on `date`)."
#
#-----------------------------------------------------------------------
#
# Set paramters used in filtering of the orography.
#
#-----------------------------------------------------------------------
#
echo
echo "Setting orography filtering parameters..."

if [ $RES -eq 48 ]; then 
  export cd4=0.12; export max_slope=0.12; export n_del2_weak=4;  export peak_fac=1.1  
elif [ $RES -eq 96 ]; then 
  export cd4=0.12; export max_slope=0.12; export n_del2_weak=8;  export peak_fac=1.1  
elif [ $RES -eq 192 ]; then 
  export cd4=0.15; export max_slope=0.12; export n_del2_weak=12; export peak_fac=1.05  
elif [ $RES -eq 384 ]; then 
  export cd4=0.15; export max_slope=0.12; export n_del2_weak=12; export peak_fac=1.0  
elif [ $RES -eq 768 ]; then 
  export cd4=0.15; export max_slope=0.12; export n_del2_weak=16; export peak_fac=1.0  
elif [ $RES -eq 1152 ]; then 
  export cd4=0.15; export max_slope=0.16; export n_del2_weak=20; export peak_fac=1.0  
elif [ $RES -eq 3072 ]; then 
  export cd4=0.15; export max_slope=0.30; export n_del2_weak=24; export peak_fac=1.0  
else
  echo
  echo "Error.  Grid resolution specified in \"RES\" is not supported:"
  echo "  RES = $RES"
  echo "RES must be one of:  48  96  192  384  768  1152  3072"
  echo "Exiting script."
  exit 1
fi
#
#-----------------------------------------------------------------------
#
# Generate a filtered orography file corresponding to tile 7 (the re-
# gional domain) only.  
#
# The following will create a filtered orography file named
#
#   oro.${CRES}.tile7.nc
#
# and will place it in WORKDIR_FLTR.  Note that this file will include
# the filtered orography for a halo of width nhalo_T7 cells around tile
# 7.
#
# The orography filtering script orog_fltr_scr copies the tile 7 grid 
# file and the mosaic file that was created above in WORKDIR_GRID and 
# the (unfiltered) tile 7 orography file created above in WORKDIR_OROG
# to WORKDIR_FLTR.  It also copies the executable that performs the fil-
# tering from exec_dir to WORKDIR_FLTR and creates a namelist file that 
# the executable needs as input.  When run, for each tile listed in the
# mosaic file, the executable replaces the unfiltered orography file 
# with its filtered counterpart (i.e. it gives the filtered file the 
# same name as the original unfiltered file).  Since in this (i.e. 
# gtype="regional") case the mosaic file lists only tile 7, a filtered
# orography file is generated only for tile 7.  Thus, the grid files for
# the first 6 tiles that were created above in WORKDIR_GRID are not used
# and thus do not need to be copied from WORKDIR_GRID to WORKDIR_FLTR 
# (to get this behavior required a small change to the orog_fltr_scr 
# script that GSK has made).
#
#-----------------------------------------------------------------------
#
echo 
echo "Begin filtering of orography (on `date`)."
$USHDIR/$orog_fltr_scr \
  $RES \
  $WORKDIR_GRID $WORKDIR_OROG $WORKDIR_FLTR \
  $cd4 $peak_fac $max_slope $n_del2_weak \
  $USHDIR $gtype
#
#-----------------------------------------------------------------------
#
# For clarity, rename the tile 7 filtered orography file such that its
# new name contains the halo size.  Then create a link whose name 
# doesn't contain the halo size that points to this file.
#
#-----------------------------------------------------------------------
#
tile=7
cd $WORKDIR_FLTR
mv ${CRES}_grid.tile${tile}.nc \
   ${CRES}_grid.tile${tile}.halo${nhalo_T7}.nc
ln -fs ${CRES}_grid.tile${tile}.halo${nhalo_T7}.nc \
       ${CRES}_grid.tile${tile}.nc
mv oro.${CRES}.tile${tile}.nc \
   oro.${CRES}.tile${tile}.halo${nhalo_T7}.nc
ln -fs oro.${CRES}.tile${tile}.halo${nhalo_T7}.nc \
       oro.${CRES}.tile${tile}.nc
cd -

echo 
echo "End filtering of orography (on `date`)."
#
#-----------------------------------------------------------------------
#
# Partially "shave" the halos from the grid and orography files to gene-
# rate new grid and orography files with thinner halos that are needed
# as inputs by the FV3SAR model.  More specifically, the 4 files that 
# the FV3SAR model will try to read are:
#
# 1) A regional (i.e. tile 7) grid file with a halo of 3 cells.
# 2) A regional (i.e. tile 7) grid file with a halo of 4 cells.
# 3) A regional (i.e. tile 7) filtered topography file without a halo
#    (i.e. a halo of 0 cells).
# 4) A regional (i.e. tile 7) filtered topography file with a halo of 4
#    cells.
#
# These are created below and placed in WORKDIR_FLTR.  Note that the 
# grid and orography files with a halo of 4 cells are also needed as in-
# puts by the chgres program to generate boundary condition (BC) files 
# with 4 rows and columns.
#
#-----------------------------------------------------------------------
#
echo
echo "\"Shaving\" regional grid and filtered orography files to reduce them to required compute size..."

cd $WORKDIR_SHVE
#
# Create an input file for the shave executable to generate a grid file
# with a halo of 3 cells.
#
echo $nx_T7 \
     $ny_T7 \
     $halo \
     \'$WORKDIR_FLTR/${CRES}_grid.tile${tile}.nc\' \
     \'$WORKDIR_SHVE/${CRES}_grid.tile${tile}.halo${halo}.nc\' > input.shave.grid.halo${halo}
#
# Create an input file for the shave executable to generate a grid file
# with a halo of 4 cells.
#
echo $nx_T7 \
     $ny_T7 \
     $halop1 \
     \'$WORKDIR_FLTR/${CRES}_grid.tile${tile}.nc\' \
     \'$WORKDIR_SHVE/${CRES}_grid.tile${tile}.halo${halop1}.nc\' > input.shave.grid.halo${halop1}
#
# Create an input file for the shave executable to generate an orography
# file without a halo.
#
echo $nx_T7 \
     $ny_T7 \
     $halo0 \
     \'$WORKDIR_FLTR/oro.${CRES}.tile${tile}.nc\' \
     \'$WORKDIR_SHVE/${CRES}_oro_data.tile${tile}.halo${halo0}.nc\' > input.shave.orog.halo${halo0}
#
# Create an input file for the shave executable to generate an orography
# file with a halo of 4 cells.
#
echo $nx_T7 \
     $ny_T7 \
     $halop1 \
     \'$WORKDIR_FLTR/oro.${CRES}.tile${tile}.nc\' \
     \'$WORKDIR_SHVE/${CRES}_oro_data.tile${tile}.halo${halop1}.nc\' > input.shave.orog.halo${halop1}
#
# Shave the grid and orography files.
#
if [ "$machine" = "WCOSS_C" ]; then

  aprun -n 1 -N 1 -j 1 -d 1 -cc depth $exec_dir/$shave_exec < input.shave.grid.halo$halo
  aprun -n 1 -N 1 -j 1 -d 1 -cc depth $exec_dir/$shave_exec < input.shave.grid.halo$halop1 
  aprun -n 1 -N 1 -j 1 -d 1 -cc depth $exec_dir/$shave_exec < input.shave.orog.halo$halo0
  aprun -n 1 -N 1 -j 1 -d 1 -cc depth $exec_dir/$shave_exec < input.shave.orog.halo$halop1

elif [ "$machine" = "THEIA" ]; then

  time $exec_dir/$shave_exec < input.shave.grid.halo$halo
  time $exec_dir/$shave_exec < input.shave.grid.halo$halop1
  time $exec_dir/$shave_exec < input.shave.orog.halo$halo0
  time $exec_dir/$shave_exec < input.shave.orog.halo$halop1

fi

echo
echo "Done \"shaving\" regional grid and filtered orography files."



