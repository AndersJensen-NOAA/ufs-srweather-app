;
; **********************************************************************
;
; File name: read_FV3SAR_grid_native.ncl
; Author: Gerard Ketefian
;
; Description:
; ^^^^^^^^^^^
; This function returns the file names, dimensions, cell center coordi-
; nates, and cell vertex coordinates of the grids associated with the 
; specified FV3 cubed-sphere tiles (tile_inds).  If get_tile_bdies is 
; set to True, it also returns the coordinates of those grid cell verti-
; ces that lie on the boundary of each specified tile.
;
; The input arguments to this function are as follows:
;
; work_dir:
; This is the work directory created by the FV3SAR workflow.  The grid
; specification files corresponding to the cubed-sphere tiles are within
; subdirectories under this directory.
;
; gtype:
; This is a string containing the grid type of the FV3 cubed-sphere grid
; being read in.  For files generated by the FV3SAR workflow, this will
; be equal to "regional".
; 
; cres:
; This is the C-resolution of the global cubed-sphere grid that serves
; as the "parent" of the regional grid.  It consists of the character 
; "C" followed by an interger that is equal to the number of grid cells
; in each of the two horizontal directions (say x and y) on each of the
; six tiles of the parent global grid.  Note that this number is in ge-
; neral not equal to the number of grid cells on the regional grid (i.e.
; the one on tile 7) because the latter is given by the former multi-
; plied by a refinement factor (an integer) that is normally greater 
; than 1.
;
; tile_inds:
; The indices of the tiles (associated with ither the parent global grid
; or the regional grid) to consider in this function.
;
; get_tile_bdies:
; A logical variable that specifies whether arrays containing the coor-
; dinates of grid cell vertices that lie on the boundary of each tile 
; specified in tile_inds are to be extracted and returned.
;
; nhalo_T7:
; The width of the halo (in units of grid cells) included in the grid 
; specification file for the regional grid (tile 7).  If tile_inds in-
; cludes tile 7, then this is used to form the name of the grid file for
; that tile.  Also, if tile_inds includes tile 7 and if remove_rgnl_halo
; is set to True, then a halo of width nhalo_T7 is removed from any ar-
; rays read in from the tile 7 grid file.  This is not used if tile_inds
; does not include tile 7.
;
; remove_rgnl_halo:
; Flag indicating whether to remove a halo of width nhalo_T7 from any
; arrays read in from the tile 7 grid file.  This is not used if tile_-
; inds does not include tile 7.
;
; **********************************************************************
;
loadscript(lib_location + "special_chars.ncl")
loadscript(lib_location + "strcmp_exact.ncl")
loadscript(lib_location + "get_rect_grid_bdy.ncl")
loadscript(lib_location + "get_rect_grid_corners.ncl")

undef("read_FV3SAR_grid_native")

function read_FV3SAR_grid_native( \
         work_dir:string, \
         gtype:string, \
         cres:string, \
         tile_inds:integer, \
         get_tile_bdies:logical, \
         nhalo_T7:integer, \
         remove_rgnl_halo:logical)

local num_tiles_to_plot, nx_all_tiles, ny_all_tiles, grid_files, \
      nn, msg, underline, n_tile, grid_fn, fp, \
      tile_SG_dims, msg_adden, \
      lon_verts_SG_crnt_tile, lat_verts_SG_crnt_tile, \
      coord_data_type, \
      lon_verts_crnt_tile, lat_verts_crnt_tile, \
      lon_cntrs_crnt_tile, lat_cntrs_crnt_tile, \
      dims_with_halo, nx_with_halo, ny_with_halo, \
      x_is_longitude, opts, corner_info, corner_lons, corner_lats, \
      fmt_str, lon_str, lat_str, \
      nx, ny, \
      lon_cntrs_crnt_tile_unstruc, lat_cntrs_crnt_tile_unstruc, \
      lon_verts_crnt_tile_unstruc, lat_verts_crnt_tile_unstruc, \
      lon_cntrs_all_tiles_unstruc, lat_cntrs_all_tiles_unstruc, \
      lon_verts_all_tiles_unstruc, lat_verts_all_tiles_unstruc, \
      repeat_lat_point, array_order, bdy_info, \
      lon_bdy_crnt_tile, lat_bdy_crnt_tile, \
      lon_bdy_all_tiles, lat_bdy_all_tiles, \
      grid_info

begin
;
; **********************************************************************
;
; If not already defined, define the string (separator_line) that serves
; as a separator line between different sections of printout.
;
; **********************************************************************
;
  if (.not. isvar("separator_line")) then
    separator_line := repeat_str("=", 72)
  end if
;
; **********************************************************************
;
; Set the full path to the grid file corresponding to each tile speci-
; fied in tile_inds and save the results in the array grid_files.  Also,
; set the horizontal dimensions of the grid corresponding to each tile
; (i.e. the number of cells in each of the two directions) and save the
; results in the arrays nx_all_tiles and ny_all_tiles.
;
; Note that for a regional grid, if one of the specified tiles is tile 7
; (which is the tile containing the regional domain/grid), then the halo
; cells that this tile includes will be removed if remove_rgnl_halo is 
; set to True.  In this case, nx_all_tiles and ny_all_tiles for tile 7
; will contain the number of cells AFTER removing the halo.
;
; **********************************************************************
;
  num_tiles_to_plot = dimsizes(tile_inds)

  nx_all_tiles = new((/ num_tiles_to_plot /), "integer")
  ny_all_tiles = new((/ num_tiles_to_plot /), "integer")
  grid_files = new((/ num_tiles_to_plot /), "string")

  print("")
  print("" + separator_line)
  print("Reading in tile grid coordinates of each specified tile from file ...")

  do nn=0, num_tiles_to_plot-1

    print("")
    msg := "nn = " + nn
    print("" + msg)
    underline = repeat_str("-", strlen(msg))
    print("" + underline)

    n_tile = tile_inds(nn)
    print("")
    print("  n_tile = " + n_tile)
;
; **********************************************************************
;
; Set the file name (including path) for the current tile.  Then save
; the resut in the grid_files array for later use.
;
; **********************************************************************
;
    grid_fn = cres + "_grid.tile" + n_tile
    if (strcmp_exact(gtype, "regional") .and. (n_tile .eq. 7)) then
      grid_fn = grid_fn + ".halo" + tostring(nhalo_T7) + ".nc"
      grid_fn = work_dir + "/shave/" + grid_fn
    else
      grid_fn = grid_fn + ".nc"
      grid_fn = work_dir + "/grid/" + grid_fn
    end if

    grid_files(nn) = grid_fn
    print("  grid_files(" + nn + ") = " + char_dq + grid_files(nn) + char_dq)
;
; **********************************************************************
;
; Open the NetCDF file containing the grid specification for the current 
; tile.
;
; **********************************************************************
;
    fp = addfile(grid_files(nn), "r")
;
; **********************************************************************
;
; Read in the dimensions of the tile's supergrid (which has twice the 
; resolution as the tile's grid).  From these, calculate the dimensions
; of the grid.
;
; **********************************************************************
;
    tile_SG_dims := getfilevardimsizes(fp, "area") 
    nx_all_tiles(nn) = tile_SG_dims(1)/2
    ny_all_tiles(nn) = tile_SG_dims(0)/2
;
; **********************************************************************
;
; If on a regional grid, if the current tile is tile 7 (the regional do-
; main/grid), and if remove_rgnl_halo is set to True, then reduce the 
; grid dimensions to ones corresponding to the tile 7 grid without a ha-
; lo of width nhalo_T7.
;
; **********************************************************************
;
    msg_adden = ""
    if (strcmp_exact(gtype, "regional") .and. \
        (n_tile .eq. 7) .and. remove_rgnl_halo) then
      nx_all_tiles(nn) = nx_all_tiles(nn) - 2*nhalo_T7
      ny_all_tiles(nn) = ny_all_tiles(nn) - 2*nhalo_T7
      msg_adden = " (AFTER removing halo of " + nhalo_T7 + " cells)"
    end if

    print("  nx_all_tiles(" + nn + ") = " + nx_all_tiles(nn) + msg_adden)
    print("  ny_all_tiles(" + nn + ") = " + ny_all_tiles(nn) + msg_adden)
;
; **********************************************************************
;
; Read in the supergrid coordinates.  The supergrid of a given tile is a
; grid having twice the resolution of the actual (i.e. computational) 
; grid of that tile.  It is used to store the coordintes of both the 
; centers and the vertices of the cells on the computational grid.
;
; **********************************************************************
; 
    lon_verts_SG_crnt_tile := fp->x(:,:)
    lat_verts_SG_crnt_tile := fp->y(:,:)
;
; **********************************************************************
;
; Get the data type (i.e. float or double) of the arrays holding the 
; tile grid coordinates.
;
; **********************************************************************
;
    coord_data_type = typeof(lon_verts_SG_crnt_tile)
;
; **********************************************************************
;
; Get the coordinates of the cell vertices on the current tile from 
; those of the supergrid.
;
; **********************************************************************
;
    lon_verts_crnt_tile := lon_verts_SG_crnt_tile(0::2,0::2)
    lat_verts_crnt_tile := lat_verts_SG_crnt_tile(0::2,0::2)
;
; **********************************************************************
;
; Get the coordinates of the cell centers on the current tile from those
; of the supergrid.
;
; **********************************************************************
;
    lon_cntrs_crnt_tile := lon_verts_SG_crnt_tile(1::2,1::2)
    lat_cntrs_crnt_tile := lat_verts_SG_crnt_tile(1::2,1::2)
;
; **********************************************************************
;
; Delete the supergrid coordinates to save memory.
;
; **********************************************************************
;
    delete([/ lon_verts_SG_crnt_tile, \
              lat_verts_SG_crnt_tile /])
;
; **********************************************************************
;
; If on a regional grid, if the current tile is tile 7 (the regional do-
; main/grid), and if remove_rgnl_halo is set to True, then remove a ha-
; lo of width nhalo_T7 from each of the coordinate arrays.
;
; **********************************************************************
;
    if (strcmp_exact(gtype, "regional") .and. \
        (n_tile .eq. 7) .and. remove_rgnl_halo) then
;
; **********************************************************************
;
; Get grid dimensions before halo is removed.
;
; **********************************************************************
;
      dims_with_halo := dimsizes(lon_cntrs_crnt_tile)
      nx_with_halo = dims_with_halo(1)
      ny_with_halo = dims_with_halo(0)

      print("")
      print("  Removing halo cells from coordinate arrays of tile " + n_tile + " ...")
;
; **********************************************************************
;
; Remove halo cells from the arrays containing the coordinates of cell
; centers.
;
; **********************************************************************
;
      lon_cntrs_crnt_tile \
      := lon_cntrs_crnt_tile( \
         nhalo_T7:ny_with_halo-1-nhalo_T7, \
         nhalo_T7:nx_with_halo-1-nhalo_T7)

      lat_cntrs_crnt_tile \
      := lat_cntrs_crnt_tile( \
         nhalo_T7:ny_with_halo-1-nhalo_T7, \
         nhalo_T7:nx_with_halo-1-nhalo_T7)
;
; **********************************************************************
;
; Remove halo cells from the arrays containing coordinates of the cell
; vertices.
;
; **********************************************************************
;
      lon_verts_crnt_tile \
      := lon_verts_crnt_tile( \
         nhalo_T7:ny_with_halo-nhalo_T7, \
         nhalo_T7:nx_with_halo-nhalo_T7)

      lat_verts_crnt_tile \
      := lat_verts_crnt_tile( \
         nhalo_T7:ny_with_halo-nhalo_T7, \
         nhalo_T7:nx_with_halo-nhalo_T7)

      print("  Done removing halo cells from coordinate arrays of tile " + n_tile + ".")

    end if
;
; **********************************************************************
;
; Find and print out the coordinates of the corners of the current tile.
;
; **********************************************************************
;
    x_is_longitude = True
    opts := True
    opts@verbose = False
    corner_info := get_rect_grid_corners( \
                   lon_verts_crnt_tile, lat_verts_crnt_tile, \
                   "deg", "deg", x_is_longitude, opts)
    corner_lons := corner_info@x_corners
    corner_lats := corner_info@y_corners

    print("")
    print("  Tile corner lon/lat coordinates are:")
    fmt_str = "%7.2f"
    do c=0, dimsizes(corner_lons)-1
      lon_str = sprintf(fmt_str, corner_lons(c))
      lat_str = sprintf(fmt_str, corner_lats(c))
      print("    Corner " + (c+1) + ":  lon = " + lon_str + " deg;  " + \
            "lat = " + lat_str + " deg")
    end do
;
; **********************************************************************
;
; For convenience, define nx and ny as the number of grid points in each
; of the two directions on the current tile.
;
; **********************************************************************
;
    nx = nx_all_tiles(nn)
    ny = ny_all_tiles(nn)
;
; **********************************************************************
;
; Create arrays in unstructured format that contain the coordinates of
; the center of each cell on the current tile.  Note that these are 1-D
; arrays, and their size (i.e. the number of elements they contain) is 
; equal to the number of cells on the current tile's grid (i.e. nx*ny).  
; This unstructured format is useful in generating color-contour plots 
; of fields on the grid that have one value per cell represented by a 
; flat color in that cell.
;
; **********************************************************************
;
    lon_cntrs_crnt_tile_unstruc := ndtooned(lon_cntrs_crnt_tile)
    lat_cntrs_crnt_tile_unstruc := ndtooned(lat_cntrs_crnt_tile)
;
; **********************************************************************
;
; Create arrays in unstructured format that contain the coordinates of
; the vertices of each cell on the current tile.  Note that these are 
; 2-D arrays whose first dimension size is the number of cells on the 
; current tile's grid (i.e. nx*ny) and whose second dimension size is 4
; (since each cell has 4 vertices).  This unstructured format is useful
; in generating color-contour plots of fields on the grid that have one
; value per cell represented by a flat color in that cell.
;
; **********************************************************************
;
    lon_verts_crnt_tile_unstruc \
    := (/ ndtooned(lon_verts_crnt_tile(0:ny-1,0:nx-1)), \
          ndtooned(lon_verts_crnt_tile(0:ny-1,1:nx)), \
          ndtooned(lon_verts_crnt_tile(1:ny,1:nx)), \
          ndtooned(lon_verts_crnt_tile(1:ny,0:nx-1)) /)
    lon_verts_crnt_tile_unstruc \
    := transpose(lon_verts_crnt_tile_unstruc)

    lat_verts_crnt_tile_unstruc \
    := (/ ndtooned(lat_verts_crnt_tile(0:ny-1,0:nx-1)), \
          ndtooned(lat_verts_crnt_tile(0:ny-1,1:nx)), \
          ndtooned(lat_verts_crnt_tile(1:ny,1:nx)), \
          ndtooned(lat_verts_crnt_tile(1:ny,0:nx-1)) /)
    lat_verts_crnt_tile_unstruc \
    := transpose(lat_verts_crnt_tile_unstruc)
;
; **********************************************************************
;
; Initialize (if on the first specified tile) or append to (if on the 
; second, third, etc, specified tiles) the unstructured arrays that will 
; contain the coordinates of the cell centers and cell vertices on all
; specified tiles.  We refer to these as the "all-tiles" arrays.  If 
; initializing, we set these "all-tiles" arrays to the unstructured ar-
; rays containing these same coordinates on the first tile.  Otherwise, 
; we append to them the coordinates on the current tile.
;
; **********************************************************************
;
    if (nn .eq. 0) then

      lon_cntrs_all_tiles_unstruc := lon_cntrs_crnt_tile_unstruc
      lat_cntrs_all_tiles_unstruc := lat_cntrs_crnt_tile_unstruc

      lon_verts_all_tiles_unstruc := lon_verts_crnt_tile_unstruc
      lat_verts_all_tiles_unstruc := lat_verts_crnt_tile_unstruc

    else

      lon_cntrs_all_tiles_unstruc \
      := array_append_record( \
         lon_cntrs_all_tiles_unstruc, lon_cntrs_crnt_tile_unstruc, 0)
      lat_cntrs_all_tiles_unstruc \
      := array_append_record( \
         lat_cntrs_all_tiles_unstruc, lat_cntrs_crnt_tile_unstruc, 0)

      lon_verts_all_tiles_unstruc \
      := array_append_record( \
         lon_verts_all_tiles_unstruc, lon_verts_crnt_tile_unstruc, 0)
      lat_verts_all_tiles_unstruc \
      := array_append_record( \
         lat_verts_all_tiles_unstruc, lat_verts_crnt_tile_unstruc, 0)

    end if
;
; **********************************************************************
;
; If get_tile_bdies is True, generate unstructured boundary coordinate
; arrays.
;
; **********************************************************************
;
    if (get_tile_bdies) then
;
; First, get the coordinates of the boundary points on the current tile.
; Here, by "boundary points", we mean those cell vertices that happen to
; lie on the tile's boundary.
;
      repeat_last_point = True
      array_order = "ji"
      bdy_info := get_rect_grid_bdy( \
                  lon_verts_crnt_tile, lat_verts_crnt_tile, \
                  repeat_last_point, array_order)
      lon_bdy_crnt_tile := bdy_info@x_bdy
      lat_bdy_crnt_tile := bdy_info@y_bdy
;
; Append a missing value after the last boundary coordinate of the cur-
; rent tile.  This missing value is used to delimit the boundary coordi-
; nates of each tile.
;
; Actually, the missing value was useful in the plotting routines to 
; prevent a line being drawn from the last point on the boundary of one
; tile to the first point on the boundary of the next tile.  Now that we
; are plotting each tile boundary as a separte polyline object, we don't
; need to add this missing value.  
;

;
; Try removing the following at some point.
;
if (insert_missing_delimiter) then
      lon_bdy_crnt_tile \
      := array_append_record(lon_bdy_crnt_tile, \
         default_fillvalue(coord_data_type), 0)

      lat_bdy_crnt_tile \
      := array_append_record(lat_bdy_crnt_tile, \
         default_fillvalue(coord_data_type), 0)
end if
;
; Now either initialize (if on the first specified tile) or append to 
; (if on the second, third, etc, specified tiles) the arrays that will 
; contain the coordinates of the boundary points on all specified tiles.  
; We refer to these as the "all-tiles" arrays.  If initializing, we set
; these "all-tiles" arrays to the arrays containing the boundary point
; coordinates for the first tile.  Otherwise, we append to them the 
; boundary point coordinates for the current tile.
;
      if (nn .eq. 0) then
        lon_bdy_all_tiles := lon_bdy_crnt_tile
        lat_bdy_all_tiles := lat_bdy_crnt_tile
      else
        lon_bdy_all_tiles \
        := array_append_record(lon_bdy_all_tiles, lon_bdy_crnt_tile, 0)
        lat_bdy_all_tiles \
        := array_append_record(lat_bdy_all_tiles, lat_bdy_crnt_tile, 0)
      end if
;
; **********************************************************************
;
; If get_tile_bdies is False, set the "all-tiles" boundary coordinate 
; arrays to default missing scalar values.  This is needed so that we
; do not get "undefined variable" errors later on when trying to return
; these arrays as attributes of the return variable.
;
; **********************************************************************
;
    else

      lon_bdy_all_tiles := default_fillvalue(coord_data_type)
      lat_bdy_all_tiles := default_fillvalue(coord_data_type)

    end if

  end do

  print("")
  print("Done reading in tile grid coordinates of each specified tile.")
  print("" + separator_line)
;
; **********************************************************************
;
; Return results as attributes of the logical variable grid_info.
;
; **********************************************************************
;
  grid_info := True

  grid_info@fp = fp
  grid_info@grid_files = grid_files
  grid_info@nx_all_tiles = nx_all_tiles
  grid_info@ny_all_tiles = ny_all_tiles
  grid_info@lon_cntrs_all_tiles_unstruc = lon_cntrs_all_tiles_unstruc
  grid_info@lat_cntrs_all_tiles_unstruc = lat_cntrs_all_tiles_unstruc
  grid_info@lon_verts_all_tiles_unstruc = lon_verts_all_tiles_unstruc
  grid_info@lat_verts_all_tiles_unstruc = lat_verts_all_tiles_unstruc
  grid_info@lon_bdy_all_tiles = lon_bdy_all_tiles
  grid_info@lat_bdy_all_tiles = lat_bdy_all_tiles
  grid_info@coord_data_type = coord_data_type

  return(grid_info)

end

